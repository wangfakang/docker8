{"name":"Docker8","tagline":"docker  struct and namespace and cgroup","body":"`关于docker架构的简单认识：  `\r\n\r\n１.宏观看docker:\r\n====\r\n首先docker是一种c/s模式的架构，分为docker client 和 docker daemon．其中docker client主要是\r\n收集用户执行的命令参数，并做简单的解析，然后解析调用相应的handler与docker daemon进行连接然后动\r\n过docker　daemon的router server 进行相应的路由处理，调用相应的函数进行response给client.      \r\n\r\n2.docker client：    \r\n=======\r\n主要是进行相关命令行的解析，然后进行向docker发送命令请求．\r\n\r\n3.docekr daemon：    \r\n=======\r\n主要就是根据client发过来的请求参数进行执行相应的handler.其组件：Docker Server、Engine和Job三部分，\r\n其中docker server是接受client的请求的，Engine主要是用来管理job的执行，job就是一个具体的任务执行．    \r\n\r\n4.docker镜像：   \r\n====\r\ndocker 进行run　image的时候生成一个容器，有这样几个概念rootfs、Union mount、image以及layer。      \r\n\r\n*  rootfs：     \r\n传统来说，Linux操作系统内核启动时，内核首先会挂载一个只读（read-only）的rootfs，当系统检测其完整性之后，\r\n决定是否将其切换为读写（read-write）模式，或者最后在rootfs之上另行挂载一种文件系统并忽略rootfs。Docker\r\n架构下，依然沿用Linux中rootfs的思想。当Docker Daemon为Docker Container挂载rootfs的时候，与传统Linux内核\r\n类似，将其设定为只读（read-only）模式。在rootfs挂载完毕之后，和Linux内核不一样的是，Docker Daemon没有将\r\nDocker Container的文件系统设为读写（read-write）模式，而是利用Union mount的技术，在这个只读的rootfs之上\r\n再挂载一个读写（read-write）的文件系统，挂载时该读写（read-write）文件系统内空无一物。       \r\n* union mount:    \r\n代表一种文件系统挂载的方式，允许同一时刻多种文件系统挂载在一起，并以一种文件系统的形式，呈现多种文件系统\r\n内容合并后的目录。  \r\n一般情况下，通过某种文件系统挂载内容至挂载点的话，挂载点目录中原先的内容将会被隐藏。而Union mount则不会将\r\n挂载点目录中的内容隐藏，反而是将挂载点目录中的内容和被挂载的内容合并，并为合并后的内容提供一个统一独立的文\r\n件系统视角。通常来讲，被合并的文件系统中只有一个会以读写（read-write）模式挂载，而其他的文件系统的挂载模式\r\n均为只读（read-only）。实现这种Union mount技术的文件系统一般被称为Union Filesystem，较为常见的有UnionFS、\r\nAUFS、OverlayFS等。          \r\n\r\n5.基础概念的简单介绍docker、lxc、cgroup、namespace是最近比较的技术。先了解一下他们分别是什么：    \r\n========\r\ndocker是lxc的管理器，lxc是cgroup的管理工具，cgroup是namespace的用户空间的管理接口。namespace是linux内核在\r\ntask_struct中对进程组管理的基础机制。    \r\nlinux中称谓的container在内核层面由两个独立的机制保证，一个保证资源的隔离性，名为namespace；一个进行资源的\r\n控制，名为cgroup。    \r\n\r\n\r\ndocker 的名字叫 lxc-docker而 LXC 又是基于 cgroup 的 namespace, chroot 等, 由于我并不懂这些, 但 namespace 可以帮助我们理解, 就像我们写\r\n程序一样, 这是一个命名空间, 与其他 namespace 相区别：       \r\ncgroup 对于 docker 是至关重要的, 了解它才会觉得 docker 不神秘, cgroup 全称为 control group, 是 linux 内核提供\r\n的功能, 简单的说, 它的作用就是把系统运行的进程按用户自定义的群组区分, 也就是说一个 docker, 一个 group　cgroup \r\n有限制使用资源的能力．    \r\n\r\n\r\n* Linux Namespaces机制提供一种资源隔离方案。PID,IPC,Network等系统资源不再是全局性的，而是属于特定的Namespace。\r\n每个Namespace里面的资源对其他Namespace都是透明的。要创建新的Namespace，只需要在调用clone时指定相应的flag。\r\nLinux Namespaces机制为实现基于容器的虚拟化技术提供了很好的基础，LXC（Linux containers）就是利用这一特性实\r\n现了资源的隔离。不同container内的进程属于不同的Namespace，彼此透明，互不干扰。下面我们就从clone系统调用的\r\nflag出发，来介绍各个Namespace。       \r\n* UTS namespace提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独\r\n立的节点而非宿主机上的一个进程．    \r\nMount namespace通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以它的标识位比\r\n较特殊，就是CLONE_NEWNS．   \r\n \r\n* Cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理\r\n资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。Cgroups也是LXC为实现虚\r\n拟化所使用的资源管理手段，可以说没有cgroups就没有LXC。       \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"docker  struct and namespace and cgroup","note":"Don't delete this file! It's used internally to help with page regeneration."}